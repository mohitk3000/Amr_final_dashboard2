{"ast":null,"code":"var _jsxFileName = \"/home/mohit/Downloads/AMRbot_dashboard/src/components/Map2.jsx\";\nimport React, { Component } from 'react';\nimport { Row, Col } from 'react-bootstrap';\nimport Config from \"../scripts/config\";\nimport * as ROSLIB from 'roslib';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass RobotState extends Component {\n  constructor() {\n    super();\n    this.state = {\n      ros: null\n    };\n    this.state = {\n      ros: new window.ROSLIB.Ros(),\n      connection: false\n    };\n    this.view_map = this.view_map.bind(this);\n  }\n  componentDidMount() {\n    // Don't need to call getRobotState() here since it's already called in the 'connection' event\n    this.initConnection();\n    this.view_map();\n    this.subscribeToRobotPose();\n    // Subscribe to the /map topic\n    const mapTopic = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/robot_pose_ekf/odom_combined\",\n      messageType: \"geometry_msgs/PoseWithCovarianceStamped\"\n    });\n    mapTopic.subscribe(message => {\n      // Log received map data to the console\n      const pose = message.pose.pose;\n\n      // Update state with the received robot position\n      this.setState({\n        robotPosition: pose\n      });\n      console.log(\"Received Map Data: \", message);\n      console.log(\"haare krishna\");\n    });\n  }\n  initConnection() {\n    this.setState({\n      ros: new window.ROSLIB.Ros()\n    });\n    console.log(\"Map: \" + this.state.ros);\n    this.state.ros.on(\"error\", error => {\n      console.error(\"ROS Error:\", error);\n    });\n    try {\n      this.state.ros.connect(\"ws://\" + Config.ROSBRIDGE_SERVER_IP + \":\" + Config.ROSBRIDGE_SERVER_PORT);\n    } catch (error) {\n      console.error(\"ws://\" + Config.ROSBRIDGE_SERVER_IP + \":\" + Config.ROSBRIDGE_SERVER_PORT);\n      console.error(\"Cannot connect to the WS robot. Try again after 1 second\");\n    }\n  }\n  viewMap() {\n    const {\n      ros\n    } = this.state;\n    if (ros) {\n      const viewer = new ROS2D.Viewer({\n        divID: 'nav_div3',\n        width: 200,\n        height: 200\n      });\n      const arrow = new ROS2D.Arrow({\n        size: 10,\n        strokeSize: 1,\n        fillColor: createjs.Graphics.getRGB(255, 0, 0)\n      });\n\n      // Add the arrow to the viewer's scene\n      viewer.scene.addChild(arrow);\n      const navClient = new ROS2D.OccupancyGridClientNav({\n        ros,\n        rootObject: viewer.scene,\n        viewer,\n        serverName: '/move_base',\n        withOrientation: true\n      });\n\n      // Update the arrow's position on each animation frame\n      viewer.addObject(arrow);\n      viewer.animate();\n      viewer.on('frameRendered', () => {\n        const {\n          robotPosition,\n          mapInfo\n        } = this.state;\n        if (robotPosition && mapInfo) {\n          // Update arrow's position based on the robot position and map information\n          const mapOrigin = mapInfo.origin.position;\n          const robotPose = robotPosition.position;\n\n          // Calculate the arrow's position relative to the map origin\n          const arrowX = (robotPose.x - mapOrigin.x) / mapInfo.resolution;\n          const arrowY = (robotPose.y - mapOrigin.y) / mapInfo.resolution;\n          arrow.x = arrowX;\n          arrow.y = arrowY;\n          arrow.rotation = Math.atan2(robotPosition.orientation.z, robotPosition.orientation.w) * (180 / Math.PI);\n        }\n      });\n    }\n  }\n\n  // ... your existing methods\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        id: \"nav_div3\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 131,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 7\n    }, this);\n  }\n}\nexport default RobotState;","map":{"version":3,"names":["React","Component","Row","Col","Config","ROSLIB","jsxDEV","_jsxDEV","RobotState","constructor","state","ros","window","Ros","connection","view_map","bind","componentDidMount","initConnection","subscribeToRobotPose","mapTopic","Topic","name","messageType","subscribe","message","pose","setState","robotPosition","console","log","on","error","connect","ROSBRIDGE_SERVER_IP","ROSBRIDGE_SERVER_PORT","viewMap","viewer","ROS2D","Viewer","divID","width","height","arrow","Arrow","size","strokeSize","fillColor","createjs","Graphics","getRGB","scene","addChild","navClient","OccupancyGridClientNav","rootObject","serverName","withOrientation","addObject","animate","mapInfo","mapOrigin","origin","position","robotPose","arrowX","x","resolution","arrowY","y","rotation","Math","atan2","orientation","z","w","PI","render","children","id","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/home/mohit/Downloads/AMRbot_dashboard/src/components/Map2.jsx"],"sourcesContent":["import React, { Component } from 'react';\nimport { Row, Col } from 'react-bootstrap';\nimport Config from \"../scripts/config\";\nimport * as ROSLIB from 'roslib';\n\n\n\nclass RobotState extends Component {\n  state={\n    ros:null,\n  };\n\n  constructor(){\n    super();\n    this.state = {\n      ros: new window.ROSLIB.Ros(),\n      connection: false,\n    };\n    this.view_map=this.view_map.bind(this)\n\n   \n  }\n  componentDidMount() {\n    // Don't need to call getRobotState() here since it's already called in the 'connection' event\n    this.initConnection();\n    this.view_map();\n    this.subscribeToRobotPose();\n     // Subscribe to the /map topic\n     const mapTopic = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/robot_pose_ekf/odom_combined\",\n      messageType: \"geometry_msgs/PoseWithCovarianceStamped\",\n    });\n\n    mapTopic.subscribe((message) => {\n      // Log received map data to the console\n      const pose = message.pose.pose;\n      \n      // Update state with the received robot position\n      this.setState({ robotPosition: pose });\n      console.log(\"Received Map Data: \", message);\n      console.log(\"haare krishna\");\n    });\n  }\n\n\n  initConnection() {\n    this.setState({ ros: new window.ROSLIB.Ros() });\n    console.log(\"Map: \" + this.state.ros);\n  \n    this.state.ros.on(\"error\", (error) => {\n      console.error(\"ROS Error:\", error);\n    });\n  \n    try {\n      this.state.ros.connect(\n        \"ws://\" +\n          Config.ROSBRIDGE_SERVER_IP +\n          \":\" +\n          Config.ROSBRIDGE_SERVER_PORT\n      );\n    } catch (error) {\n      console.error(\n        \"ws://\" +\n          Config.ROSBRIDGE_SERVER_IP +\n          \":\" +\n          Config.ROSBRIDGE_SERVER_PORT\n      );\n      console.error(\"Cannot connect to the WS robot. Try again after 1 second\");\n    }\n  }\n\n\n  \n  viewMap() {\n    const { ros } = this.state;\n  \n    if (ros) {\n      const viewer = new ROS2D.Viewer({\n        divID: 'nav_div3',\n        width: 200,\n        height: 200,\n      });\n  \n      const arrow = new ROS2D.Arrow({\n        size: 10,\n        strokeSize: 1,\n        fillColor: createjs.Graphics.getRGB(255, 0, 0),\n      });\n  \n      // Add the arrow to the viewer's scene\n      viewer.scene.addChild(arrow);\n  \n      const navClient = new ROS2D.OccupancyGridClientNav({\n        ros,\n        rootObject: viewer.scene,\n        viewer,\n        serverName: '/move_base',\n        withOrientation: true,\n      });\n  \n      // Update the arrow's position on each animation frame\n      viewer.addObject(arrow);\n      viewer.animate();\n  \n      viewer.on('frameRendered', () => {\n        const { robotPosition, mapInfo } = this.state;\n  \n        if (robotPosition && mapInfo) {\n          // Update arrow's position based on the robot position and map information\n          const mapOrigin = mapInfo.origin.position;\n          const robotPose = robotPosition.position;\n          \n          // Calculate the arrow's position relative to the map origin\n          const arrowX = (robotPose.x - mapOrigin.x) / mapInfo.resolution;\n          const arrowY = (robotPose.y - mapOrigin.y) / mapInfo.resolution;\n  \n          arrow.x = arrowX;\n          arrow.y = arrowY;\n          arrow.rotation = Math.atan2(robotPosition.orientation.z, robotPosition.orientation.w) * (180 / Math.PI);\n        }\n      });\n    }\n  }\n  \n  // ... your existing methods\n\n  render() {\n    return (\n      <div>\n        <div id=\"nav_div3\"></div>\n      </div>\n    );\n  }\n}\n\n\nexport default RobotState;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}